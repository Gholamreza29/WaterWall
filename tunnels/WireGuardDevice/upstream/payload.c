#include "structure.h"

#include "loggers/network_logger.h"

static wireguard_peer_t *peerLookupByAllowedIp(wireguard_device_t *device, const ip_addr_t *ipaddr)
{
    wireguard_peer_t *result = NULL;
    wireguard_peer_t *tmp;
    int               x;
    int               y;
    for (x = 0; (! result) && (x < WIREGUARD_MAX_PEERS); x++)
    {
        tmp = &device->peers[x];
        if (tmp->valid)
        {
            for (y = 0; y < WIREGUARD_MAX_SRC_IPS; y++)
            {
                if ((tmp->allowed_source_ips[y].valid) &&
                    ipAddrNetcmp(ipaddr, &tmp->allowed_source_ips[y].ip, &tmp->allowed_source_ips[y].mask))
                {
                    result = tmp;
                    break;
                }
            }
        }
    }
    return result;
}

err_t wireguardifOutputToPeer(wireguard_device_t *device, sbuf_t *q, const ip_addr_t *ipaddr, wireguard_peer_t *peer)
{
    // The LWIP IP layer wants to send an IP packet out over the interface - we need to encrypt and send it to the peer
    message_transport_data_t *hdr;
    sbuf_t                   *buf;
    err_t                     result;
    size_t                    unpadded_len;
    size_t                    padded_len;
    size_t                    header_len = 16;
    uint8_t                  *dst;
    uint32_t                  now;
    wireguard_keypair_t      *keypair = &peer->curr_keypair;

    // Note: We may not be able to use the current keypair if we haven't received data, may need to resort to using
    // previous keypair
    if (keypair->valid && (! keypair->initiator) && (keypair->last_rx == 0))
    {
        keypair = &peer->prev_keypair;
    }

    if (keypair->valid && (keypair->initiator || keypair->last_rx != 0))
    {

        if (! wireguardExpired(keypair->keypair_millis, REJECT_AFTER_TIME) &&
            (keypair->sending_counter < REJECT_AFTER_MESSAGES))
        {

            // Calculate the outgoing packet size - round up to next 16 bytes, add 16 bytes for header
            if (q)
            {
                // This is actual transport data
                unpadded_len = q->tot_len;
            }
            else
            {
                // This is a keep-alive
                unpadded_len = 0;
            }
            padded_len = (unpadded_len + 15) & 0xFFFFFFF0; // Round up to next 16 byte boundary

            // The buffer needs to be allocated from "transport" pool to leave room for LwIP generated IP headers
            // The IP packet consists of 16 byte header (struct message_transport_data), data padded upto 16 byte
            // boundary + encrypted auth tag (16 bytes)
            buf = pbufAlloc(sbuf_tRANSPORT, header_len + padded_len + WIREGUARD_AUTHTAG_LEN, PBUF_RAM);
            if (buf)
            {
                // Note: allocating buf from RAM above guarantees that the buf is in one section and not chained
                // - i.e payload points to the contiguous memory region
                memset(buf->payload, 0, buf->tot_len);

                hdr = (message_transport_data_t *) buf->payload;

                hdr->type     = MESSAGE_TRANSPORT_DATA;
                hdr->receiver = keypair->remote_index;
                // Alignment required... pbuf_alloc has probably aligned data, but want to be sure
                U64TO8_LITTLE(hdr->counter, keypair->sending_counter);

                // Copy the encrypted (padded) data to the output packet - chacha20poly1305_encrypt() can encrypt data
                // in-place which avoids call to mem_malloc
                dst = &hdr->enc_packet[0];
                if ((padded_len > 0) && q)
                {
                    // Note: before copying make sure we have inserted the IP header checksum
                    // The IP header checksum (and other checksums in the IP packet - e.g. ICMP) need to be calculated
                    // by LWIP before calling The Wireguard interface always needs checksums to be generated in software
                    // but the base ts may have some checksums generated by hardware

                    // Copy buf to memory - handles case where buf is chained
                    pbufCopyPartial(q, dst, unpadded_len, 0);
                }

                // Then encrypt
                wireguard_encrypt_packet(dst, dst, padded_len, keypair);

                result = wireguardifPeerOutput(ts, buf, peer);

                if (result == ERR_OK)
                {
                    now              = getTickMS();
                    peer->last_tx    = now;
                    keypair->last_tx = now;
                }

                pbufFree(buf);

                // Check to see if we should rekey
                if (keypair->sending_counter >= REKEY_AFTER_MESSAGES)
                {
                    peer->send_handshake = true;
                }
                else if (keypair->initiator && wireguardExpired(keypair->keypair_millis, REKEY_AFTER_TIME))
                {
                    peer->send_handshake = true;
                }
            }
            else
            {
                // Failed to allocate memory
                result = ERR_MEM;
            }
        }
        else
        {
            // key has expired...
            keypairDestroy(keypair);
            result = ERR_CONN;
        }
    }
    else
    {
        // No valid keys!
        result = ERR_CONN;
    }
    return result;
}




// This is used as the output function for the Wireguard ts
// The ipaddr here is the one inside the VPN which we use to lookup the correct peer/endpoint
static err_t wireguardifOutput(wireguard_device_t *device, sbuf_t *q, const ip_addr_t *ipaddr)
{
    wireguard_device_t *device = &(ts->wg_device);
    // Send to peer that matches dest IP
    wireguard_peer_t *peer = peerLookupByAllowedIp(device, ipaddr);
    if (peer)
    {
        return wireguardifOutputToPeer(ts, q, ipaddr, peer);
    }
    else
    {
        return ERR_RTE;
    }
}

void wireguarddeviceTunnelUpStreamPayload(tunnel_t *t, line_t *l, sbuf_t *buf)
{
    tunnelNextUpStreamPayload(t, l, buf);
}
