#include "structure.h"
#include "wcrypto.h"
#include "wwapi.h"

static void updatePeerAddr(wireguard_peer_t *peer, const ip_address_t *addr, uint16_t port)
{
    peer->ip   = *addr;
    peer->port = port;
}

static wireguard_peer_t *peerLookupByAllowedIp(wireguard_device_t *device, const ip_address_t *ipaddr)
{
    wireguard_peer_t *result = NULL;
    wireguard_peer_t *tmp;
    int               x;
    int               y;
    for (x = 0; (! result) && (x < WIREGUARD_MAX_PEERS); x++)
    {
        tmp = &device->peers[x];
        if (tmp->valid)
        {
            for (y = 0; y < WIREGUARD_MAX_SRC_IPS; y++)
            {
                if ((tmp->allowed_source_ips[y].valid) &&
                    ipAddrNetcmp(ipaddr, &tmp->allowed_source_ips[y].ip, &tmp->allowed_source_ips[y].mask))
                {
                    result = tmp;
                    break;
                }
            }
        }
    }
    return result;
}


static err_t wireguardifOutputToPeer(wgd_tstate_t *ts, sbuf_t *q, const ip_address_t *ipaddr, wireguard_peer_t *peer)
{
    // The LWIP IP layer wants to send an IP packet out over the interface - we need to encrypt and send it to the peer
    message_transport_data_t *hdr;
    sbuf_t                   *pbuf;
    err_t                     result;
    size_t                    unpadded_len;
    size_t                    padded_len;
    size_t                    header_len = 16;
    uint8_t                  *dst;
    uint32_t                  now;
    wireguard_keypair_t      *keypair = &peer->curr_keypair;

    // Note: We may not be able to use the current keypair if we haven't received data, may need to resort to using
    // previous keypair
    if (keypair->valid && (! keypair->initiator) && (keypair->last_rx == 0))
    {
        keypair = &peer->prev_keypair;
    }

    if (keypair->valid && (keypair->initiator || keypair->last_rx != 0))
    {

        if (! wireguardExpired(keypair->keypair_millis, REJECT_AFTER_TIME) &&
            (keypair->sending_counter < REJECT_AFTER_MESSAGES))
        {

            // Calculate the outgoing packet size - round up to next 16 bytes, add 16 bytes for header
            if (q)
            {
                // This is actual transport data
                unpadded_len = q->tot_len;
            }
            else
            {
                // This is a keep-alive
                unpadded_len = 0;
            }
            padded_len = (unpadded_len + 15) & 0xFFFFFFF0; // Round up to next 16 byte boundary

            // The buffer needs to be allocated from "transport" pool to leave room for LwIP generated IP headers
            // The IP packet consists of 16 byte header (struct message_transport_data), data padded upto 16 byte
            // boundary + encrypted auth tag (16 bytes)
            pbuf = pbufAlloc(sbuf_tRANSPORT, header_len + padded_len + WIREGUARD_AUTHTAG_LEN, PBUF_RAM);
            if (pbuf)
            {
                // Note: allocating pbuf from RAM above guarantees that the pbuf is in one section and not chained
                // - i.e payload points to the contiguous memory region
                memset(pbuf->payload, 0, pbuf->tot_len);

                hdr = (message_transport_data_t *) pbuf->payload;

                hdr->type     = MESSAGE_TRANSPORT_DATA;
                hdr->receiver = keypair->remote_index;
                // Alignment required... pbuf_alloc has probably aligned data, but want to be sure
                U64TO8_LITTLE(hdr->counter, keypair->sending_counter);

                // Copy the encrypted (padded) data to the output packet - chacha20poly1305_encrypt() can encrypt data
                // in-place which avoids call to mem_malloc
                dst = &hdr->enc_packet[0];
                if ((padded_len > 0) && q)
                {
                    // Note: before copying make sure we have inserted the IP header checksum
                    // The IP header checksum (and other checksums in the IP packet - e.g. ICMP) need to be calculated
                    // by LWIP before calling The Wireguard interface always needs checksums to be generated in software
                    // but the base ts may have some checksums generated by hardware

                    // Copy pbuf to memory - handles case where pbuf is chained
                    pbufCopyPartial(q, dst, unpadded_len, 0);
                }

                // Then encrypt
                wireguard_encrypt_packet(dst, dst, padded_len, keypair);

                result = wireguardifPeerOutput(ts, pbuf, peer);

                if (result == ERR_OK)
                {
                    now              = getTickMS();
                    peer->last_tx    = now;
                    keypair->last_tx = now;
                }

                pbufFree(pbuf);

                // Check to see if we should rekey
                if (keypair->sending_counter >= REKEY_AFTER_MESSAGES)
                {
                    peer->send_handshake = true;
                }
                else if (keypair->initiator && wireguardExpired(keypair->keypair_millis, REKEY_AFTER_TIME))
                {
                    peer->send_handshake = true;
                }
            }
            else
            {
                // Failed to allocate memory
                result = ERR_MEM;
            }
        }
        else
        {
            // key has expired...
            keypairDestroy(keypair);
            result = ERR_CONN;
        }
    }
    else
    {
        // No valid keys!
        result = ERR_CONN;
    }
    return result;
}

// This is used as the output function for the Wireguard ts
// The ipaddr here is the one inside the VPN which we use to lookup the correct peer/endpoint
static err_t wireguardifOutput(wgd_tstate_t *ts, sbuf_t *q, const ip_address_t *ipaddr)
{
    wireguard_device_t *device = (wireguard_device_t *) ts->state;
    // Send to peer that matches dest IP
    wireguard_peer_t *peer = peerLookupByAllowedIp(device, ipaddr);
    if (peer)
    {
        return wireguardifOutputToPeer(ts, q, ipaddr, peer);
    }
    else
    {
        return ERR_RTE;
    }
}




static bool peerAddIp(wireguard_peer_t *peer, ip_address_t ip, ip_address_t mask)
{
    bool                    result = false;
    wireguard_allowed_ip_t *allowed;
    int                     x;
    // Look for existing match first
    for (x = 0; x < WIREGUARD_MAX_SRC_IPS; x++)
    {
        allowed = &peer->allowed_source_ips[x];
        if ((allowed->valid) && ipAddrCmp(&allowed->ip, &ip) && ipAddrCmp(&allowed->mask, &mask))
        {
            result = true;
            break;
        }
    }
    if (! result)
    {
        // Look for a free slot
        for (x = 0; x < WIREGUARD_MAX_SRC_IPS; x++)
        {
            allowed = &peer->allowed_source_ips[x];
            if (! allowed->valid)
            {
                allowed->valid = true;
                allowed->ip    = ip;
                allowed->mask  = mask;
                result         = true;
                break;
            }
        }
    }
    return result;
}

static void wireguardifProcessDataMessage(wireguard_device_t *device, wireguard_peer_t *peer,
                                          message_transport_data_t *data_hdr, size_t data_len, const ip_address_t *addr,
                                          uint16_t port)
{
    wireguard_keypair_t *keypair;
    uint64_t             nonce;
    uint8_t             *src;
    size_t               src_len;
    sbuf_t              *pbuf;
    iphdr_t            *iphdr;
    ip_address_t         dest;
    bool                 dest_ok = false;
    int                  x;
    uint32_t             now;
    uint16_t             header_len = 0xFFFF;
    uint32_t             idx        = data_hdr->receiver;

    keypair = get_peer_keypair_for_idx(peer, idx);

    if (keypair)
    {
        if ((keypair->receiving_valid) && ! wireguardExpired(keypair->keypair_millis, REJECT_AFTER_TIME) &&
            (keypair->sending_counter < REJECT_AFTER_MESSAGES)

        )
        {

            nonce   = U8TO64_LITTLE(data_hdr->counter);
            src     = &data_hdr->enc_packet[0];
            src_len = data_len;

            // We don't know the unpadded size until we have decrypted the packet and validated/inspected the IP header
            pbuf = pbufAlloc(sbuf_tRANSPORT, src_len - WIREGUARD_AUTHTAG_LEN, PBUF_RAM);
            if (pbuf)
            {
                // Decrypt the packet
                memset(pbuf->payload, 0, pbuf->tot_len);
                if (wireguard_decrypt_packet(pbuf->payload, src, src_len, nonce, keypair))
                {

                    // 3. Since the packet has authenticated correctly, the source IP of the outer UDP/IP packet is used
                    // to update the endpoint for peer TrMv...WXX0. Update the peer location
                    updatePeerAddr(peer, addr, port);

                    now              = getTickMS();
                    keypair->last_rx = now;
                    peer->last_rx    = now;

                    // Might need to shuffle next key --> current keypair
                    keypair_update(peer, keypair);

                    // Check to see if we should rekey
                    if (keypair->initiator &&
                        wireguardExpired(keypair->keypair_millis,
                                         REJECT_AFTER_TIME - peer->keepalive_interval - REKEY_TIMEOUT))
                    {
                        peer->send_handshake = true;
                    }

                    // Make sure that link is reported as up
                    netifSetLinkUp(device->ts);

                    if (pbuf->tot_len > 0)
                    {
                        // 4a. Once the packet payload is decrypted, the interface has a plaintext packet. If this is
                        // not an IP packet, it is dropped.
                        iphdr = (iphdr_t *) pbuf->payload;
                        // Check for packet replay / dupes
                        if (wireguard_check_replay(keypair, nonce))
                        {

                            // 4b. Otherwise, WireGuard checks to see if the source IP address of the plaintext
                            // inner-packet routes correspondingly in the cryptokey routing table Also check packet
                            // length!
#if LWIP_IPV4
                            if (IPH_V(iphdr) == 4)
                            {
                                ipAddrCopyFromIp4(dest, iphdr->dest);
                                for (x = 0; x < WIREGUARD_MAX_SRC_IPS; x++)
                                {
                                    if (peer->allowed_source_ips[x].valid)
                                    {
                                        if (ipAddrNetcmp(&dest, &peer->allowed_source_ips[x].ip,
                                                           &peer->allowed_source_ips[x].mask))
                                        {
                                            dest_ok    = true;
                                            header_len = PP_NTOHS(IPH_LEN(iphdr));
                                            break;
                                        }
                                    }
                                }
                            }
#endif /* LWIP_IPV4 */
#if LWIP_IPV6
                            if (IPH_V(iphdr) == 6)
                            {
                                // TODO: IPV6 support for route filtering
                                header_len = PP_NTOHS(IPH_LEN(iphdr));
                                dest_ok    = true;
                            }
#endif /* LWIP_IPV6 */
                            if (header_len <= pbuf->tot_len)
                            {

                                // 5. If the plaintext packet has not been dropped, it is inserted into the receive
                                // queue of the wg0 interface.
                                if (dest_ok)
                                {
                                    // Send packet to be process by LWIP
                                    ip_input(pbuf, device->ts);
                                    // pbuf is owned by IP layer now
                                    pbuf = NULL;
                                }
                            }
                            else
                            {
                                // IP header is corrupt or lied about packet size
                            }
                        }
                        else
                        {
                            // This is a duplicate packet / replayed / too far out of order
                        }
                    }
                    else
                    {
                        // This was a keep-alive packet
                    }
                }

                if (pbuf)
                {
                    pbufFree(pbuf);
                }
            }
        }
        else
        {
            // After Reject-After-Messages transport data messages or after the current secure session is Reject-
            // After-Time seconds old,
            //  whichever comes first, WireGuard will refuse to send or receive any more transport data messages using
            //  the current secure session, until a new secure session is created through the 1-RTT handshake
            keypairDestroy(keypair);
        }
    }
    else
    {
        // Could not locate valid keypair for remote index
    }
}


static void wireguardifSendHandshakeResponse(wireguard_device_t *device, wireguard_peer_t *peer)
{
    message_handshake_response_t packet;
    sbuf_t                      *pbuf = NULL;
    err_t                        err  = ERR_OK;

    if (wireguard_create_handshake_response(device, peer, &packet))
    {

        wireguard_start_session(peer, false);

        // Send this packet out!
        pbuf = pbufAlloc(sbuf_tRANSPORT, sizeof(message_handshake_response_t), PBUF_RAM);
        if (pbuf)
        {
            err = pbufTake(pbuf, &packet, sizeof(message_handshake_response_t));
            if (err == ERR_OK)
            {
                // OK!
                wireguardifPeerOutput(device->ts, pbuf, peer);
            }
            pbufFree(pbuf);
        }
    }
}

static size_t getSourceAddrPort(const ip_address_t *addr, uint16_t port, uint8_t *buf, size_t buflen)
{
    size_t result = 0;

#if LWIP_IPV4
    if (IP_IS_V4(addr) && (buflen >= 4))
    {
        U32TO8_BIG(buf + result, PP_NTOHL(ip4AddrGetU32(addr)));
        result += 4;
    }
#endif
#if LWIP_IPV6
    if (IP_IS_V4(addr) && (buflen >= 16))
    {
        U16TO8_BIG(buf + result + 0, IP6_ADDR_BLOCK1(addr));
        U16TO8_BIG(buf + result + 2, IP6_ADDR_BLOCK2(addr));
        U16TO8_BIG(buf + result + 4, IP6_ADDR_BLOCK3(addr));
        U16TO8_BIG(buf + result + 6, IP6_ADDR_BLOCK4(addr));
        U16TO8_BIG(buf + result + 8, IP6_ADDR_BLOCK5(addr));
        U16TO8_BIG(buf + result + 10, IP6_ADDR_BLOCK6(addr));
        U16TO8_BIG(buf + result + 12, IP6_ADDR_BLOCK7(addr));
        U16TO8_BIG(buf + result + 14, IP6_ADDR_BLOCK8(addr));
        result += 16;
    }
#endif
    if (buflen >= result + 2)
    {
        U16TO8_BIG(buf + result, port);
        result += 2;
    }
    return result;
}

static void wireguardifSendHandshakeCookie(wireguard_device_t *device, const uint8_t *mac1, uint32_t index,
                                           const ip_address_t *addr, uint16_t port)
{
    message_cookie_reply_t packet;
    sbuf_t                *pbuf = NULL;
    err_t                  err  = ERR_OK;
    uint8_t                source_buf[18];
    size_t                 source_len = getSourceAddrPort(addr, port, source_buf, sizeof(source_buf));

    wireguard_create_cookie_reply(device, &packet, mac1, index, source_buf, source_len);

    // Send this packet out!
    pbuf = pbufAlloc(sbuf_tRANSPORT, sizeof(message_cookie_reply_t), PBUF_RAM);
    if (pbuf)
    {
        err = pbufTake(pbuf, &packet, sizeof(message_cookie_reply_t));
        if (err == ERR_OK)
        {
            wireguardifDeviceOutput(device, pbuf, addr, port);
        }
        pbufFree(pbuf);
    }
}

static bool wireguardifCheckInitiationMessage(wireguard_device_t *device, message_handshake_initiation_t *msg,
                                              const ip_address_t *addr, uint16_t port)
{
    bool     result = false;
    uint8_t *data   = (uint8_t *) msg;
    uint8_t  source_buf[18];
    size_t   source_len;
    // We received an initiation packet check it is valid

    if (wireguard_check_mac1(device, data, sizeof(message_handshake_initiation_t) - (2 * WIREGUARD_COOKIE_LEN),
                             msg->mac1))
    {
        // mac1 is valid!
        if (! wireguard_is_under_load())
        {
            // If we aren't under load we only need mac1 to be correct
            result = true;
        }
        else
        {
            // If we are under load then check mac2
            source_len = getSourceAddrPort(addr, port, source_buf, sizeof(source_buf));

            result = wireguard_check_mac2(device, data, sizeof(message_handshake_initiation_t) - (WIREGUARD_COOKIE_LEN),
                                          source_buf, source_len, msg->mac2);

            if (! result)
            {
                // mac2 is invalid (cookie may have expired) or not present
                // 5.3 Denial of Service Mitigation & Cookies
                // If the responder receives a message with a valid msg.mac1 yet with an invalid msg.mac2, and is under
                // load, it may respond with a cookie reply message
                wireguardifSendHandshakeCookie(device, msg->mac1, msg->sender, addr, port);
            }
        }
    }
    else
    {
        // mac1 is invalid
    }
    return result;
}

static bool wireguardifCheckResponseMessage(wireguard_device_t *device, message_handshake_response_t *msg,
                                            const ip_address_t *addr, uint16_t port)
{
    bool     result = false;
    uint8_t *data   = (uint8_t *) msg;
    uint8_t  source_buf[18];
    size_t   source_len;
    // We received an initiation packet check it is valid

    if (wireguard_check_mac1(device, data, sizeof(message_handshake_response_t) - (2 * WIREGUARD_COOKIE_LEN),
                             msg->mac1))
    {
        // mac1 is valid!
        if (! wireguard_is_under_load())
        {
            // If we aren't under load we only need mac1 to be correct
            result = true;
        }
        else
        {
            // If we are under load then check mac2
            source_len = getSourceAddrPort(addr, port, source_buf, sizeof(source_buf));

            result = wireguard_check_mac2(device, data, sizeof(message_handshake_response_t) - (WIREGUARD_COOKIE_LEN),
                                          source_buf, source_len, msg->mac2);

            if (! result)
            {
                // mac2 is invalid (cookie may have expired) or not present
                // 5.3 Denial of Service Mitigation & Cookies
                // If the responder receives a message with a valid msg.mac1 yet with an invalid msg.mac2, and is under
                // load, it may respond with a cookie reply message
                wireguardifSendHandshakeCookie(device, msg->mac1, msg->sender, addr, port);
            }
        }
    }
    else
    {
        // mac1 is invalid
    }
    return result;
}




static err_t wireguardifLookupPeer(wgd_tstate_t *ts, uint8_t peer_index, wireguard_peer_t **out)
{
    LWIP_ASSERT("ts != NULL", (ts != NULL));
    LWIP_ASSERT("state != NULL", (ts->state != NULL));
    wireguard_device_t *device = (wireguard_device_t *) ts->state;
    wireguard_peer_t   *peer   = NULL;
    err_t               result;

    if (device->valid)
    {
        peer = peerLookupByPeerIndex(device, peer_index);
        if (peer)
        {
            result = ERR_OK;
        }
        else
        {
            result = ERR_ARG;
        }
    }
    else
    {
        result = ERR_ARG;
    }
    *out = peer;
    return result;
}

err_t wireguardifConnect(wgd_tstate_t *ts, uint8_t peer_index)
{
    wireguard_peer_t *peer;
    err_t             result = wireguardifLookupPeer(ts, peer_index, &peer);
    if (result == ERR_OK)
    {
        // Check that a valid connect ip and port have been set
        if (! ipAddrIsAny(&peer->connect_ip) && (peer->connect_port > 0))
        {
            // Set the flag that we want to try connecting
            peer->active = true;
            peer->ip     = peer->connect_ip;
            peer->port   = peer->connect_port;
            result       = ERR_OK;
        }
        else
        {
            result = ERR_ARG;
        }
    }
    return result;
}

err_t wireguardifDisconnect(wgd_tstate_t *ts, uint8_t peer_index)
{
    wireguard_peer_t *peer;
    err_t             result = wireguardifLookupPeer(ts, peer_index, &peer);
    if (result == ERR_OK)
    {
        // Set the flag that we want to try connecting
        peer->active = false;
        // Wipe out current keys
        keypairDestroy(&peer->next_keypair);
        keypairDestroy(&peer->curr_keypair);
        keypairDestroy(&peer->prev_keypair);
        result = ERR_OK;
    }
    return result;
}

err_t wireguardifPeerIsUp(wgd_tstate_t *ts, uint8_t peer_index, ip_address_t *current_ip, uint16_t *current_port)
{
    wireguard_peer_t *peer;
    err_t             result = wireguardifLookupPeer(ts, peer_index, &peer);
    if (result == ERR_OK)
    {
        if ((peer->curr_keypair.valid) || (peer->prev_keypair.valid))
        {
            result = ERR_OK;
        }
        else
        {
            result = ERR_CONN;
        }
        if (current_ip)
        {
            *current_ip = peer->ip;
        }
        if (current_port)
        {
            *current_port = peer->port;
        }
    }
    return result;
}

err_t wireguardifRemovePeer(wgd_tstate_t *ts, uint8_t peer_index)
{
    wireguard_peer_t *peer;
    err_t             result = wireguardifLookupPeer(ts, peer_index, &peer);
    if (result == ERR_OK)
    {
        cryptoZero(peer, sizeof(wireguard_peer_t));
        peer->valid = false;
        result      = ERR_OK;
    }
    return result;
}

err_t wireguardifUpdateEndpoint(wgd_tstate_t *ts, uint8_t peer_index, const ip_address_t *ip, uint16_t port)
{
    wireguard_peer_t *peer;
    err_t             result = wireguardifLookupPeer(ts, peer_index, &peer);
    if (result == ERR_OK)
    {
        peer->connect_ip   = *ip;
        peer->connect_port = port;
        result             = ERR_OK;
    }
    return result;
}




void wireguardifPeerInit(wireguardif_peer_t *peer)
{
    LWIP_ASSERT("peer != NULL", (peer != NULL));
    memset(peer, 0, sizeof(wireguardif_peer_t));
    // Caller must provide 'public_key'
    peer->public_key = NULL;
    ip4AddrSetAny(&peer->endpoint_ip);
    peer->endport_port = WIREGUARDIF_DEFAULT_PORT;
    peer->keep_alive   = WIREGUARDIF_KEEPALIVE_DEFAULT;
    ip4AddrSetAny(&peer->allowed_ip);
    ip4AddrSetAny(&peer->allowed_mask);
    memset(peer->greatest_timestamp, 0, sizeof(peer->greatest_timestamp));
    peer->preshared_key = NULL;
}
